<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> [译]你可能并不需要要衍生state · DAY DREAM</title><meta name="description" content="[译]你可能并不需要要衍生state - Ryanchill"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="DAY DREAM"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAG</a></li><li class="nav-list-item"><a href="https://github.com/ryanchill94" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"><i class="fa fa-search" aria-hidden="true"></i></a></li></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">[译]你可能并不需要要衍生state</h1><div class="post-info">2018年10月6日<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span></div><div class="post-content"><blockquote>
<p>原文链接:<br><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">You Probably Don’t Need Derived State</a>（略有删减）</p>
</blockquote>
<p>React 16.4 发布了一个关于 DerivedStateFromProps 生命周期函数的 bugfix，这个 bug 会导致现有 React 已知的 bug 更加频繁得复现，如果这个版本暴露了你的应用程序使用了反模式并且在修复后不能正常工作的情况下，我们对此感到抱歉。 在本文中，我们将解释一些常见的反模式与派生状态和我们首选的替代方案。</p>
<p>在很长一段时间里，生命周期组件 componentWillReceiveProps 是在没有额外渲染的情况下响应 props 变化的唯一方法。 在 16.3 版本中，我们引入了一个替代生命周期，getDerivedStateFromProps 以一种更安全的方式来解决相同的用例。 与此同时，我们意识到人们对于如何使用这两种方法有很多误解，我们发现反模式会导致微妙和混乱的错误。 16.4 中的 getDerivedStateFromProps bugfix 使派生 state 更容易预测，所以错误使用它的结果更容易被发现。</p>
<blockquote>
<p>所有的在下文中介绍的反模式无论是旧的<code>componentWillReceiveProps</code>还是新的<code>getDerivedStateFromProps</code>都可能存在</p>
</blockquote>
<p>这篇博客包含以下几个话题：</p>
<ul>
<li>什么时候可以使用衍生 state</li>
<li>使用衍生 state 时常见的 bug<ul>
<li>反模式: 无条件的将 props 复制到 state 上</li>
<li>反模式: prop 一旦发生变更就把 state 清除掉</li>
</ul>
</li>
<li>更佳的解决方案</li>
<li>尝试使用记忆化?</li>
</ul>
<h2 id="什么时候可以使用衍生-state"><a href="#什么时候可以使用衍生-state" class="headerlink" title="什么时候可以使用衍生 state"></a>什么时候可以使用衍生 state</h2><p><code>getDerivedStateFromProps</code>存在目的只有一个。 它使一个组件可以响应<strong>props 的改变</strong>来更新其内部状态。 我们之前的博客文章提供了一些例子，比如基于变化 offest props 来记录当前的滚动方向，或者通过 source props 来确定加载哪些外部数据。</p>
<p>我们没有提供很多例子，因为一般来说，派生状态应该谨慎使用。 我们所看到的所有派生状态导致出现问题最终都可以归结为: (1)无条件地从 props 更新状态，或者(2)只要 props 和 match 不匹配就更新状态。 (我们将在下面详细讨论这两个问题。)</p>
<p>如果你使用派生状态来仅仅用来记忆化一些通过 props 计算的的衍生数据，那么你不需要派生状态。 看看下文的使用记忆化章节。</p>
<p>如果你无条件地更新派生 state 或者当 props 和 state 不匹配时就更新它，那么您的组件可能会过于频繁地重置它的 state。 更多细节请继续阅读。</p>
<h2 id="使用衍生-state-带来的常见-bug"><a href="#使用衍生-state-带来的常见-bug" class="headerlink" title="使用衍生 state 带来的常见 bug"></a>使用衍生 state 带来的常见 bug</h2><p>“控制”和”不受控制”通常用来描述表单输入，同时它们也可以描述任何组件的存在位置。作为 props 传入的数据通常被认为是受控的(因为父组件控制了数据)。只存在于内部状态的数据可以被认为是不受控制的(因为父母不能直接改变它)。</p>
<p>对派生状态最常见的错误是混合了这两种模式; 当一个派生 state 的值也被 setState 调用更新时，数据没有一个单一的数据源。 上面提到的加载外部数据的例子听起来可能很相似，但是在一些重要的方面有所不同。 在加载例子中，对于”资源（source）”props 和”加载”state 来说，都有一个明确的数据源。 当 source props 发生变化时，应该总是重写加载状态。 相反地，只有当 pros 改变才能被改写否则由组件以其他方式管理。</p>
<p>当任何这些约束没有遵守时，问题就会出现。 这通常有两种形式。 让我们来看看这两者。</p>
<h4 id="反模式-无条件地将-props-复制到-state"><a href="#反模式-无条件地将-props-复制到-state" class="headerlink" title="反模式: 无条件地将 props 复制到 state"></a>反模式: 无条件地将 props 复制到 state</h4><p>一个常见的误解是，只有当 props「改变」的时候， getDerivedStateFromProps 和 getDerivedStateFromProps 才会被调用。 这些生命周期会在任何父组件重新渲染的时候被调用，不管 props 是否与之前的「不同」。 因此，无条件地使用这些生命周期中的任何一个来无条件地重写状态是不安全的。 这样做会导致状态更新丢失。</p>
<p>让我们举一个例子来说明这个问题。 下面是一个电子邮件输入组件，它在 state 中”映射”了一个电子邮件 props:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.email &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = event =&gt; &#123;</span><br><span class="line">    this.setState(&#123; email: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    // This will erase any local state updates!</span><br><span class="line">    // Do not do this.</span><br><span class="line">    this.setState(&#123; email: nextProps.email &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，这个组件看起来还可以。state 被初始化为由 props 指定的值，并在向<code>&lt;input&gt;</code>输入时进行更新。 但是如果组件的父组件重新渲染，<code>&lt;input&gt;</code>框输入的任何东西都会丢失！ <a href="https://codesandbox.io/s/m3w9zn1z8x" target="_blank" rel="noopener">(参见这个演示例子。)</a>，即使在重置之前，我们比较<code>nextProps.email !== this.state.email</code>也是如此。</p>
<p>在这个简单的例子中，添加 shouldComponentUpdate 来确保只在 email props 发生变化时重新渲染可以解决。然而在实践中，组件通常接受多个 props; 其他 props 的改变仍然会导致重新渲染和不适当的重置。 函数和 props 对象通常是内联创建的，因此很难去实现一个只有当发生了<strong>实质性变化</strong>时，才能可靠地返回 true 的<code>shouldComponentUpdate</code>。 这里有一个<a href="https://codesandbox.io/s/jl0w6r9w59" target="_blank" rel="noopener">demo</a>描述了这种场景, 因此，componentupdate 最好用作性能优化，而不是确保派生 state 的正确性。</p>
<p>但愿现在你已经很清楚了，为什么无条件地将 props 复制到 state 是一个坏主意。在回顾可能的解决方案之前，让我们来看看一个相关的问题模式: 如果我们只当 email props 发生改变更新 state？</p>
<h4 id="反模式-props-发生变化时擦除-state"><a href="#反模式-props-发生变化时擦除-state" class="headerlink" title="反模式: props 发生变化时擦除 state"></a>反模式: props 发生变化时擦除 state</h4><p>继续上面的例子，我们可以避免意外地删除状态，通过只在 email props 变化时更新:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.email</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// Any time props.email changes, update state.</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.email !== <span class="keyword">this</span>.props.email) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        email: nextProps.email</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚刚取得了很大的进步。 现在我们的组件只有在 props 实际改变的时候才会删除我们输入的内容。</p>
<p>还有一个微妙的问题。 设想一个使用上述输入组件的密码管理应用程序。 当使用相同的电子邮件在两个账户的详情页之间导航时，输入将不能重置。 这是因为传递给组件的 props 的值对两个帐户都是一样的！ 这对用户来说会出乎意料，因为一个账户的未保存的更改将会影响到其他账户，应为 email props 是共享的。 <a href="https://codesandbox.io/s/mz2lnkjkrx" target="_blank" rel="noopener">(见这里的 demo)</a></p>
<p>这种设计从根本上讲是有缺陷的，同时也是一个容易犯的错误。 (我自己也犯过!) 幸运的是，有两种更好的替代方案。两者的关键在于，对于任何一条数据，你需要选择一个单独的组件作为数据来源，并避免在其他组件中重复它。让我们来看看每一种替代方案。</p>
<hr>
<h2 id="更好的解决方案"><a href="#更好的解决方案" class="headerlink" title="更好的解决方案"></a>更好的解决方案</h2><h4 id="建议方案-完全控制组件"><a href="#建议方案-完全控制组件" class="headerlink" title="建议方案: 完全控制组件"></a>建议方案: 完全控制组件</h4><p>避免上面提到的问题的一个方法是完全从我们的组件中移除 state。 如果电子邮件地址只是作为一个 props 存在，那么我们就不必担心与 state 的冲突。 我们甚至可以把 EmailInput 转换成一个更轻的函数组件:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmailInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;props.onChange&#125; value=&#123;props.email&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法简化了组件的实现，但是如果我们仍然想存储一个原始值，那么父级表单组件现在需要手动实现。 <a href="https://codesandbox.io/s/6v1znlxyxn" target="_blank" rel="noopener">(点击这里查看这个模式下的 demo)</a></p>
<h4 id="建议方案-带-key-值的完全不受控制的组件"><a href="#建议方案-带-key-值的完全不受控制的组件" class="headerlink" title="建议方案: 带 key 值的完全不受控制的组件"></a>建议方案: 带 key 值的完全不受控制的组件</h4><p>另一种选择是我们的组件完全拥有”原始”电子邮件 state。 在这种情况下，我们组件仍然可以接受一个 prop 作为初始值，但是它会忽略后续 prop 的改变:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.defaultEmail &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在选择其他选项时候重置值(如密码管理器场景)，我们可以使用叫<code>Key</code>的特殊的<code>React</code>属性。 当一个<code>Key</code>更改时，<code>React</code> 将创建一个新的组件实例，而不是更新当前的实例。 <code>Keys</code> 通常用于动态列表，但在这里也很有用。 在我们的例子里，我们可以使用用户 ID 重新生成 email input 组件，一旦选择了新用户:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;EmailInput defaultEmail=&#123;<span class="keyword">this</span>.props.user.email&#125; key=&#123;<span class="keyword">this</span>.props.user.id&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>每次 ID 更改时，<code>EmailInput</code> 将被重新创建，它的 state 将被重置到最新的默认值。 <a href="https://codesandbox.io/s/6v1znlxyxn" target="_blank" rel="noopener">(demo)</a> 使用这种方法，您不必为每个输入添加<code>Key</code>值。 把<code>key</code>放在整个表格上可能更有意义。 每次<code>key</code>变化时，表单中的所有组件都将用一个新的初始化 state 重新创建。</p>
<p>在大多数情况下，这是处理需要重置的状态的最佳方式。</p>
<blockquote>
<p>虽然这听起来很慢，但是性能差异通常是微不足道的。 如果组件具有很重的逻辑，并且在更新中运行，那么使用一个 key 值甚至可以更快，因为 diff 的时候会绕过子树。</p>
</blockquote>
<h4 id="备选方案-1-用-ID-prop-重置不受控制的组件"><a href="#备选方案-1-用-ID-prop-重置不受控制的组件" class="headerlink" title="备选方案 1: 用 ID prop 重置不受控制的组件"></a>备选方案 1: 用 ID prop 重置不受控制的组件</h4><p>如果<code>Key</code>因为某些原因不能工作(也许初始化这个组件是非常昂贵的) ，那么一个可行但繁琐的解决方案就是在 getDerivedStateFromProps 中监听<code>userID</code>的更改:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail,</span><br><span class="line">    prevPropsUserID: <span class="keyword">this</span>.props.userID</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// Any time the current user changes,</span></span><br><span class="line">    <span class="comment">// Reset any parts of state that are tied to that user.</span></span><br><span class="line">    <span class="comment">// In this simple example, that's just the email.</span></span><br><span class="line">    <span class="keyword">if</span> (props.userID !== state.prevPropsUserID) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        prevPropsUserID: props.userID,</span><br><span class="line">        email: props.defaultEmail</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以灵活的重置我们组件内部部分内部状态 <a href="https://codesandbox.io/s/rjyvp7l3rq" target="_blank" rel="noopener">demo</a></p>
<h4 id="备选方案-2-用实例方法重置不受控件"><a href="#备选方案-2-用实例方法重置不受控件" class="headerlink" title="备选方案 2: 用实例方法重置不受控件"></a>备选方案 2: 用实例方法重置不受控件</h4><p>更少见的情况是，即使没有合适的 ID 作为 Key 值，你也可能需要重置状态。 一个解决方案是将 key 值重置成随机值或自递增数。 另一个可行的替代方法是暴露一个实例方法，以危险地重置内部状态:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  resetEmailForNewUser(newEmail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: newEmail &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，父表单组件可以使用 ref 调用此方法。 <a href="https://codesandbox.io/s/l70krvpykl" target="_blank" rel="noopener">demo</a></p>
<p>在某些情况下，Refs 可能是很有用的，但是一般来说我们建议你谨慎使用它。 即使在 demo 中，这个命令方法也是非理想的，因为一次渲染会变成两次。</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾一下，当设计一个组件时，决定它的数据是可控制的还是不受控制的是非常重要的。</p>
<p>不要试图在 state 中”映射”一个 prop 的值，而是把组件变成可控组件，并在父组件的 state 中将两个值建立联系。 例如，与其让子组件接受一个”commit”的值并且监听一个”draft”state 值，不如让父组件同时管理<code>state.draftValue</code>和<code>state.committedValue</code>，并直接控制子组件的的值。 这使得数据流向更加明确和可预测。</p>
<p>对于不受控制的组件，如果您试图重置状态，当某个特定的 prop(通常是 ID)发生变化时，你有几个选项:</p>
<p>推荐: 使用 key 值重置所有内部状态。</p>
<p>备选方案 1: 只重置某些状态字段，监听特殊属性(如 props.userID)的更改。</p>
<p>备选方案 2: 考虑使用 refs 获取组件实例方法。</p>
<h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>我们常看到派生状态被用于保存计算代价昂贵的衍生值，仅当在输入发生改变时才重新计算。这种技术被称为 memoization。</p>
<p>使用派生状态来实现记忆化并不一定是坏的，但它通常不是最好的解决方案。在管理派生状态方面有内在的复杂性，这种复杂性随着每个附加属性的增加而增加。例如，如果我们在组件状态中添加第二个派生字段，那么我们的实现将需要单独跟踪这两者的更改。</p>
<p>让我们来看一个例子，其中一个组件需要一个 prop<em>一个项目列表</em>，并将与用户输入的搜索查询匹配的项目呈现出来。 我们可以使用派生状态来存储筛选列表:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    filterText: <span class="string">""</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// *******************************************************</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> this example is NOT the recommended approach.</span></span><br><span class="line">  <span class="comment">// See the examples below for our recommendations instead.</span></span><br><span class="line">  <span class="comment">// *******************************************************</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// Re-run the filter whenever the list array or filter text change.</span></span><br><span class="line">    <span class="comment">// Note we need to store prevPropsList and prevFilterText to detect changes.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      props.list !== state.prevPropsList ||</span><br><span class="line">      state.prevFilterText !== state.filterText</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        prevPropsList: props.list,</span><br><span class="line">        prevFilterText: state.filterText,</span><br><span class="line">        filteredList: props.list.filter(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">          item.text.includes(state.filterText)</span><br><span class="line">        )</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种实现避免了重新计算文件列表的次数多于必要的次数。 但是比需要的要复杂得多，因为它必须分别跟踪和检测 prop 和 state 的变化，以适当更新筛选列表。 在这个例子中，我们可以通过使用 PureComponent 和将 filter 操作移动到<code>render</code>方法中来简化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PureComponents only rerender if at least one state or prop value changes.</span></span><br><span class="line"><span class="comment">// Change is determined by doing a shallow comparison of state and prop keys.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// State only needs to hold the current filter text value:</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    filterText: <span class="string">""</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// The render method on this PureComponent is called only if</span></span><br><span class="line">    <span class="comment">// props.list or state.filterText has changed.</span></span><br><span class="line">    <span class="keyword">const</span> filteredList = <span class="keyword">this</span>.props.list.filter(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">      item.text.includes(<span class="keyword">this</span>.state.filterText)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上述方法比派生状态版更为干净和简单。 有时候，这样做不够好，对于大型列表来说，过滤可能是缓慢的，如果其他 props 发生改变的话，PureComponent 不会阻止重新渲染。 为了解决这两个问题，我们可以添加一个记忆化辅助函数，以避免不必要地重新过滤我们的列表:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">"memoize-one"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// State only needs to hold the current filter text value:</span></span><br><span class="line">  state = &#123; <span class="attr">filterText</span>: <span class="string">""</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-run the filter whenever the list array or filter text changes:</span></span><br><span class="line">  filter = memoize(<span class="function">(<span class="params">list, filterText</span>) =&gt;</span></span><br><span class="line">    list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.text.includes(filterText))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Calculate the latest filtered list. If these arguments haven't changed</span></span><br><span class="line">    <span class="comment">// since the last render, `memoize-one` will reuse the last return value.</span></span><br><span class="line">    <span class="keyword">const</span> filteredList = <span class="keyword">this</span>.filter(<span class="keyword">this</span>.props.list, <span class="keyword">this</span>.state.filterText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个同样很简单，并且与派生状态版本功能一致！</p>
<p>使用 memoization 时，请记住一些准则:</p>
<ol>
<li>在大多数情况下，您会希望将拥有记忆化的函数添加到组件实例中。 这样可以防止组件的多个实例从重置对方的<code>memoized keys</code>。</li>
</ol>
<p>2.通常情况下，你需要使用一个缓存大小有限的记忆化辅助器，以防止随着时间的推移导致内存泄漏。 (在上面的例子中，我们使用 memoize-one，因为它只缓存最近的参数和结果。)</p>
<ol start="3">
<li>如果每次父组件渲染时<code>props.list</code>重新创建，则此节中所示的任何实现都不会有效。 但在大多数情况下，这种设置是合适的。</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的工程之中，组件通常包含一系列受控和不受控制的行为。这是可以接受的！如果每一个值都有一个清晰数据源，你可以避免上面提到的反模式。</p>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/React/">#React</a><a href="/tags/Translation/">#Translation</a></p></article></div><footer><div class="paginator"><a href="/2018/09/30/five-bad-parts-fix-in-es6/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com">Ryanchill</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>