<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DAY DREAM</title>
  
  <subtitle>go big or go home</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-28T17:26:13.527Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ryanchill</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译]你可能并不需要要衍生state</title>
    <link href="http://yoursite.com/2018/10/06/you-dont-need-dervied-state/"/>
    <id>http://yoursite.com/2018/10/06/you-dont-need-dervied-state/</id>
    <published>2018-10-06T14:11:58.000Z</published>
    <updated>2018-10-28T17:26:13.527Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接:<br><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">You Probably Don’t Need Derived State</a>（略有删减）</p></blockquote><p>React 16.4 发布了一个关于 DerivedStateFromProps 生命周期函数的 bugfix，这个 bug 会导致现有 React 已知的 bug 更加频繁得复现，如果这个版本暴露了你的应用程序使用了反模式并且在修复后不能正常工作的情况下，我们对此感到抱歉。 在本文中，我们将解释一些常见的反模式与派生状态和我们首选的替代方案。</p><p>在很长一段时间里，生命周期组件 componentWillReceiveProps 是在没有额外渲染的情况下响应 props 变化的唯一方法。 在 16.3 版本中，我们引入了一个替代生命周期，getDerivedStateFromProps 以一种更安全的方式来解决相同的用例。 与此同时，我们意识到人们对于如何使用这两种方法有很多误解，我们发现反模式会导致微妙和混乱的错误。 16.4 中的 getDerivedStateFromProps bugfix 使派生 state 更容易预测，所以错误使用它的结果更容易被发现。</p><blockquote><p>所有的在下文中介绍的反模式无论是旧的<code>componentWillReceiveProps</code>还是新的<code>getDerivedStateFromProps</code>都可能存在</p></blockquote><p>这篇博客包含以下几个话题：</p><ul><li>什么时候可以使用衍生 state</li><li>使用衍生 state 时常见的 bug<ul><li>反模式: 无条件的将 props 复制到 state 上</li><li>反模式: prop 一旦发生变更就把 state 清除掉</li></ul></li><li>更佳的解决方案</li><li>尝试使用记忆化?</li></ul><h2 id="什么时候可以使用衍生-state"><a href="#什么时候可以使用衍生-state" class="headerlink" title="什么时候可以使用衍生 state"></a>什么时候可以使用衍生 state</h2><p><code>getDerivedStateFromProps</code>存在目的只有一个。 它使一个组件可以响应<strong>props 的改变</strong>来更新其内部状态。 我们之前的博客文章提供了一些例子，比如基于变化 offest props 来记录当前的滚动方向，或者通过 source props 来确定加载哪些外部数据。</p><p>我们没有提供很多例子，因为一般来说，派生状态应该谨慎使用。 我们所看到的所有派生状态导致出现问题最终都可以归结为: (1)无条件地从 props 更新状态，或者(2)只要 props 和 match 不匹配就更新状态。 (我们将在下面详细讨论这两个问题。)</p><p>如果你使用派生状态来仅仅用来记忆化一些通过 props 计算的的衍生数据，那么你不需要派生状态。 看看下文的使用记忆化章节。</p><p>如果你无条件地更新派生 state 或者当 props 和 state 不匹配时就更新它，那么您的组件可能会过于频繁地重置它的 state。 更多细节请继续阅读。</p><h2 id="使用衍生-state-带来的常见-bug"><a href="#使用衍生-state-带来的常见-bug" class="headerlink" title="使用衍生 state 带来的常见 bug"></a>使用衍生 state 带来的常见 bug</h2><p>“控制”和”不受控制”通常用来描述表单输入，同时它们也可以描述任何组件的存在位置。作为 props 传入的数据通常被认为是受控的(因为父组件控制了数据)。只存在于内部状态的数据可以被认为是不受控制的(因为父母不能直接改变它)。</p><p>对派生状态最常见的错误是混合了这两种模式; 当一个派生 state 的值也被 setState 调用更新时，数据没有一个单一的数据源。 上面提到的加载外部数据的例子听起来可能很相似，但是在一些重要的方面有所不同。 在加载例子中，对于”资源（source）”props 和”加载”state 来说，都有一个明确的数据源。 当 source props 发生变化时，应该总是重写加载状态。 相反地，只有当 pros 改变才能被改写否则由组件以其他方式管理。</p><p>当任何这些约束没有遵守时，问题就会出现。 这通常有两种形式。 让我们来看看这两者。</p><h4 id="反模式-无条件地将-props-复制到-state"><a href="#反模式-无条件地将-props-复制到-state" class="headerlink" title="反模式: 无条件地将 props 复制到 state"></a>反模式: 无条件地将 props 复制到 state</h4><p>一个常见的误解是，只有当 props「改变」的时候， getDerivedStateFromProps 和 getDerivedStateFromProps 才会被调用。 这些生命周期会在任何父组件重新渲染的时候被调用，不管 props 是否与之前的「不同」。 因此，无条件地使用这些生命周期中的任何一个来无条件地重写状态是不安全的。 这样做会导致状态更新丢失。</p><p>让我们举一个例子来说明这个问题。 下面是一个电子邮件输入组件，它在 state 中”映射”了一个电子邮件 props:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.email &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = event =&gt; &#123;</span><br><span class="line">    this.setState(&#123; email: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    // This will erase any local state updates!</span><br><span class="line">    // Do not do this.</span><br><span class="line">    this.setState(&#123; email: nextProps.email &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这个组件看起来还可以。state 被初始化为由 props 指定的值，并在向<code>&lt;input&gt;</code>输入时进行更新。 但是如果组件的父组件重新渲染，<code>&lt;input&gt;</code>框输入的任何东西都会丢失！ <a href="https://codesandbox.io/s/m3w9zn1z8x" target="_blank" rel="noopener">(参见这个演示例子。)</a>，即使在重置之前，我们比较<code>nextProps.email !== this.state.email</code>也是如此。</p><p>在这个简单的例子中，添加 shouldComponentUpdate 来确保只在 email props 发生变化时重新渲染可以解决。然而在实践中，组件通常接受多个 props; 其他 props 的改变仍然会导致重新渲染和不适当的重置。 函数和 props 对象通常是内联创建的，因此很难去实现一个只有当发生了<strong>实质性变化</strong>时，才能可靠地返回 true 的<code>shouldComponentUpdate</code>。 这里有一个<a href="https://codesandbox.io/s/jl0w6r9w59" target="_blank" rel="noopener">demo</a>描述了这种场景, 因此，componentupdate 最好用作性能优化，而不是确保派生 state 的正确性。</p><p>但愿现在你已经很清楚了，为什么无条件地将 props 复制到 state 是一个坏主意。在回顾可能的解决方案之前，让我们来看看一个相关的问题模式: 如果我们只当 email props 发生改变更新 state？</p><h4 id="反模式-props-发生变化时擦除-state"><a href="#反模式-props-发生变化时擦除-state" class="headerlink" title="反模式: props 发生变化时擦除 state"></a>反模式: props 发生变化时擦除 state</h4><p>继续上面的例子，我们可以避免意外地删除状态，通过只在 email props 变化时更新:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.email</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="comment">// Any time props.email changes, update state.</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.email !== <span class="keyword">this</span>.props.email) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        email: nextProps.email</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚刚取得了很大的进步。 现在我们的组件只有在 props 实际改变的时候才会删除我们输入的内容。</p><p>还有一个微妙的问题。 设想一个使用上述输入组件的密码管理应用程序。 当使用相同的电子邮件在两个账户的详情页之间导航时，输入将不能重置。 这是因为传递给组件的 props 的值对两个帐户都是一样的！ 这对用户来说会出乎意料，因为一个账户的未保存的更改将会影响到其他账户，应为 email props 是共享的。 <a href="https://codesandbox.io/s/mz2lnkjkrx" target="_blank" rel="noopener">(见这里的 demo)</a></p><p>这种设计从根本上讲是有缺陷的，同时也是一个容易犯的错误。 (我自己也犯过!) 幸运的是，有两种更好的替代方案。两者的关键在于，对于任何一条数据，你需要选择一个单独的组件作为数据来源，并避免在其他组件中重复它。让我们来看看每一种替代方案。</p><hr><h2 id="更好的解决方案"><a href="#更好的解决方案" class="headerlink" title="更好的解决方案"></a>更好的解决方案</h2><h4 id="建议方案-完全控制组件"><a href="#建议方案-完全控制组件" class="headerlink" title="建议方案: 完全控制组件"></a>建议方案: 完全控制组件</h4><p>避免上面提到的问题的一个方法是完全从我们的组件中移除 state。 如果电子邮件地址只是作为一个 props 存在，那么我们就不必担心与 state 的冲突。 我们甚至可以把 EmailInput 转换成一个更轻的函数组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmailInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;input onChange=&#123;props.onChange&#125; value=&#123;props.email&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法简化了组件的实现，但是如果我们仍然想存储一个原始值，那么父级表单组件现在需要手动实现。 <a href="https://codesandbox.io/s/6v1znlxyxn" target="_blank" rel="noopener">(点击这里查看这个模式下的 demo)</a></p><h4 id="建议方案-带-key-值的完全不受控制的组件"><a href="#建议方案-带-key-值的完全不受控制的组件" class="headerlink" title="建议方案: 带 key 值的完全不受控制的组件"></a>建议方案: 带 key 值的完全不受控制的组件</h4><p>另一种选择是我们的组件完全拥有”原始”电子邮件 state。 在这种情况下，我们组件仍然可以接受一个 prop 作为初始值，但是它会忽略后续 prop 的改变:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.defaultEmail &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在选择其他选项时候重置值(如密码管理器场景)，我们可以使用叫<code>Key</code>的特殊的<code>React</code>属性。 当一个<code>Key</code>更改时，<code>React</code> 将创建一个新的组件实例，而不是更新当前的实例。 <code>Keys</code> 通常用于动态列表，但在这里也很有用。 在我们的例子里，我们可以使用用户 ID 重新生成 email input 组件，一旦选择了新用户:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;EmailInput defaultEmail=&#123;<span class="keyword">this</span>.props.user.email&#125; key=&#123;<span class="keyword">this</span>.props.user.id&#125; /&gt;</span><br></pre></td></tr></table></figure><p>每次 ID 更改时，<code>EmailInput</code> 将被重新创建，它的 state 将被重置到最新的默认值。 <a href="https://codesandbox.io/s/6v1znlxyxn" target="_blank" rel="noopener">(demo)</a> 使用这种方法，您不必为每个输入添加<code>Key</code>值。 把<code>key</code>放在整个表格上可能更有意义。 每次<code>key</code>变化时，表单中的所有组件都将用一个新的初始化 state 重新创建。</p><p>在大多数情况下，这是处理需要重置的状态的最佳方式。</p><blockquote><p>虽然这听起来很慢，但是性能差异通常是微不足道的。 如果组件具有很重的逻辑，并且在更新中运行，那么使用一个 key 值甚至可以更快，因为 diff 的时候会绕过子树。</p></blockquote><h4 id="备选方案-1-用-ID-prop-重置不受控制的组件"><a href="#备选方案-1-用-ID-prop-重置不受控制的组件" class="headerlink" title="备选方案 1: 用 ID prop 重置不受控制的组件"></a>备选方案 1: 用 ID prop 重置不受控制的组件</h4><p>如果<code>Key</code>因为某些原因不能工作(也许初始化这个组件是非常昂贵的) ，那么一个可行但繁琐的解决方案就是在 getDerivedStateFromProps 中监听<code>userID</code>的更改:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail,</span><br><span class="line">    prevPropsUserID: <span class="keyword">this</span>.props.userID</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// Any time the current user changes,</span></span><br><span class="line">    <span class="comment">// Reset any parts of state that are tied to that user.</span></span><br><span class="line">    <span class="comment">// In this simple example, that's just the email.</span></span><br><span class="line">    <span class="keyword">if</span> (props.userID !== state.prevPropsUserID) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        prevPropsUserID: props.userID,</span><br><span class="line">        email: props.defaultEmail</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以灵活的重置我们组件内部部分内部状态 <a href="https://codesandbox.io/s/rjyvp7l3rq" target="_blank" rel="noopener">demo</a></p><h4 id="备选方案-2-用实例方法重置不受控件"><a href="#备选方案-2-用实例方法重置不受控件" class="headerlink" title="备选方案 2: 用实例方法重置不受控件"></a>备选方案 2: 用实例方法重置不受控件</h4><p>更少见的情况是，即使没有合适的 ID 作为 Key 值，你也可能需要重置状态。 一个解决方案是将 key 值重置成随机值或自递增数。 另一个可行的替代方法是暴露一个实例方法，以危险地重置内部状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  resetEmailForNewUser(newEmail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: newEmail &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，父表单组件可以使用 ref 调用此方法。 <a href="https://codesandbox.io/s/l70krvpykl" target="_blank" rel="noopener">demo</a></p><p>在某些情况下，Refs 可能是很有用的，但是一般来说我们建议你谨慎使用它。 即使在 demo 中，这个命令方法也是非理想的，因为一次渲染会变成两次。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾一下，当设计一个组件时，决定它的数据是可控制的还是不受控制的是非常重要的。</p><p>不要试图在 state 中”映射”一个 prop 的值，而是把组件变成可控组件，并在父组件的 state 中将两个值建立联系。 例如，与其让子组件接受一个”commit”的值并且监听一个”draft”state 值，不如让父组件同时管理<code>state.draftValue</code>和<code>state.committedValue</code>，并直接控制子组件的的值。 这使得数据流向更加明确和可预测。</p><p>对于不受控制的组件，如果您试图重置状态，当某个特定的 prop(通常是 ID)发生变化时，你有几个选项:</p><p>推荐: 使用 key 值重置所有内部状态。</p><p>备选方案 1: 只重置某些状态字段，监听特殊属性(如 props.userID)的更改。</p><p>备选方案 2: 考虑使用 refs 获取组件实例方法。</p><h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>我们常看到派生状态被用于保存计算代价昂贵的衍生值，仅当在输入发生改变时才重新计算。这种技术被称为 memoization。</p><p>使用派生状态来实现记忆化并不一定是坏的，但它通常不是最好的解决方案。在管理派生状态方面有内在的复杂性，这种复杂性随着每个附加属性的增加而增加。例如，如果我们在组件状态中添加第二个派生字段，那么我们的实现将需要单独跟踪这两者的更改。</p><p>让我们来看一个例子，其中一个组件需要一个 prop<em>一个项目列表</em>，并将与用户输入的搜索查询匹配的项目呈现出来。 我们可以使用派生状态来存储筛选列表:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    filterText: <span class="string">""</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// *******************************************************</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> this example is NOT the recommended approach.</span></span><br><span class="line">  <span class="comment">// See the examples below for our recommendations instead.</span></span><br><span class="line">  <span class="comment">// *******************************************************</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// Re-run the filter whenever the list array or filter text change.</span></span><br><span class="line">    <span class="comment">// Note we need to store prevPropsList and prevFilterText to detect changes.</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      props.list !== state.prevPropsList ||</span><br><span class="line">      state.prevFilterText !== state.filterText</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        prevPropsList: props.list,</span><br><span class="line">        prevFilterText: state.filterText,</span><br><span class="line">        filteredList: props.list.filter(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">          item.text.includes(state.filterText)</span><br><span class="line">        )</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这种实现避免了重新计算文件列表的次数多于必要的次数。 但是比需要的要复杂得多，因为它必须分别跟踪和检测 prop 和 state 的变化，以适当更新筛选列表。 在这个例子中，我们可以通过使用 PureComponent 和将 filter 操作移动到<code>render</code>方法中来简化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PureComponents only rerender if at least one state or prop value changes.</span></span><br><span class="line"><span class="comment">// Change is determined by doing a shallow comparison of state and prop keys.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// State only needs to hold the current filter text value:</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    filterText: <span class="string">""</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// The render method on this PureComponent is called only if</span></span><br><span class="line">    <span class="comment">// props.list or state.filterText has changed.</span></span><br><span class="line">    <span class="keyword">const</span> filteredList = <span class="keyword">this</span>.props.list.filter(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">      item.text.includes(<span class="keyword">this</span>.state.filterText)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上述方法比派生状态版更为干净和简单。 有时候，这样做不够好，对于大型列表来说，过滤可能是缓慢的，如果其他 props 发生改变的话，PureComponent 不会阻止重新渲染。 为了解决这两个问题，我们可以添加一个记忆化辅助函数，以避免不必要地重新过滤我们的列表:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">"memoize-one"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// State only needs to hold the current filter text value:</span></span><br><span class="line">  state = &#123; <span class="attr">filterText</span>: <span class="string">""</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-run the filter whenever the list array or filter text changes:</span></span><br><span class="line">  filter = memoize(<span class="function">(<span class="params">list, filterText</span>) =&gt;</span></span><br><span class="line">    list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.text.includes(filterText))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Calculate the latest filtered list. If these arguments haven't changed</span></span><br><span class="line">    <span class="comment">// since the last render, `memoize-one` will reuse the last return value.</span></span><br><span class="line">    <span class="keyword">const</span> filteredList = <span class="keyword">this</span>.filter(<span class="keyword">this</span>.props.list, <span class="keyword">this</span>.state.filterText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这个同样很简单，并且与派生状态版本功能一致！</p><p>使用 memoization 时，请记住一些准则:</p><ol><li>在大多数情况下，您会希望将拥有记忆化的函数添加到组件实例中。 这样可以防止组件的多个实例从重置对方的<code>memoized keys</code>。</li></ol><p>2.通常情况下，你需要使用一个缓存大小有限的记忆化辅助器，以防止随着时间的推移导致内存泄漏。 (在上面的例子中，我们使用 memoize-one，因为它只缓存最近的参数和结果。)</p><ol start="3"><li>如果每次父组件渲染时<code>props.list</code>重新创建，则此节中所示的任何实现都不会有效。 但在大多数情况下，这种设置是合适的。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的工程之中，组件通常包含一系列受控和不受控制的行为。这是可以接受的！如果每一个值都有一个清晰数据源，你可以避免上面提到的反模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接:&lt;br&gt;&lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="Translation" scheme="http://yoursite.com/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>[译]5个在ES6中被修复的Javascript缺陷</title>
    <link href="http://yoursite.com/2018/09/30/five-bad-parts-fix-in-es6/"/>
    <id>http://yoursite.com/2018/09/30/five-bad-parts-fix-in-es6/</id>
    <published>2018-09-30T09:06:51.000Z</published>
    <updated>2018-10-28T17:26:30.300Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 6 的特性可以被分为以下几种类型</p><ul><li><ol><li>纯语法糖，比如 <code>class</code> 语法</li></ol></li><li><ol start="2"><li>JavaScript 增强性  功能，比如 <code>import</code></li></ol></li><li><ol start="3"><li>修复了 JS 中一些缺陷，比如 <code>let</code> 关键字</li></ol></li></ul><p>本文着重分析第三种类型，接下来，让我们来了解下 JavaScript 中哪些「Bad Parts」被 ES6 修复了。</p><blockquote><p> 我希望当你阅读完本文，你可以意识到使用一些简单 ES6 特性给你带来的巨大便利。</p></blockquote><h3 id="1-Block-Scope"><a href="#1-Block-Scope" class="headerlink" title="1. Block Scope"></a>1. Block Scope</h3><p>ES5 只有函数作用域(比如你定义在函数块里面的代码来形成作用域),因此带来了很多问题, ES6  提供了「块级别」的作用域（通过大括号包裹），同时使用 <code>let</code>  和 <code>const</code> 来代替 <code>var</code>。</p><h4 id="防止变量提升到外部作用域"><a href="#防止变量提升到外部作用域" class="headerlink" title="防止变量提升到外部作用域"></a>防止变量提升到外部作用域</h4><p>下面的例子可以看出来 变量 <code>bouns</code>没有被提升到 <code>if</code> 块级作用域之外 ， 变得其他像大多数编程语言那样可预测。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSalary</span>(<span class="params">addBonus</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (addBonus) &#123;</span><br><span class="line">    <span class="keyword">var</span> bonus = <span class="number">100</span>; <span class="comment">// 会被提升至if作用域之外</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base + bonus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base + bonus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">false</span>)); <span class="comment">// NaN 因为变量 bonus 被提升了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">true</span>)); <span class="comment">// 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSalary</span>(<span class="params">addBonus</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (addBonus) &#123;</span><br><span class="line">    <span class="keyword">let</span> bonus = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base + bonus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base + bonus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">false</span>)); <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">true</span>)); <span class="comment">// 1100</span></span><br></pre></td></tr></table></figure><h4 id="防止重复定义变量"><a href="#防止重复定义变量" class="headerlink" title="防止重复定义变量"></a>防止重复定义变量</h4><p>ES6 不允许使用<code>let</code>或者<code>const</code>定义的变量在同一个作用域中重复定义，这有效的避免了不同库之间的函数表达式的重复（注：这里翻译有点问题，原文为:This is very helpful in avoiding duplicate function expressions coming from different libraries ）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b; <span class="comment">// 会抛出重复定义错误</span></span><br></pre></td></tr></table></figure><h4 id="取代-IIFE-的功能"><a href="#取代-IIFE-的功能" class="headerlink" title="取代 IIFE 的功能"></a>取代 IIFE 的功能</h4><p>在 ES5，就像下面的例子， 我们不得不使用立即执行函数(IIFE)来确保全局作用域不会被污染，在 ES6 中，我们只需要简单的把代码包裹在<code>{}</code>中,使用 <code>let</code> 和 <code>const</code>  来定义变量就可以获得相同的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.betterJQ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Version <span class="subst">$&#123;<span class="built_in">window</span>.bettterJQ.version&#125;</span> already exists`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> version = <span class="string">"v0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Better JQuery"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> betterJQ = &#123;</span><br><span class="line">      name,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      ajax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="string">"requst!"</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.betterJQ = betterJQ; <span class="comment">// 挂载到全局对象上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.betterJQ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Version <span class="subst">$&#123;<span class="built_in">window</span>.bettterJQ.version&#125;</span> already exists`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> version = <span class="string">"v0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">"Better JQuery"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> betterJQ = &#123;</span><br><span class="line">      name,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      ajax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="string">"requst!"</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.betterJQ = betterJQ; <span class="comment">// 挂载到全局对象上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(version); <span class="comment">// Reference Error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Reference Error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(betterJQ.version); <span class="comment">// v0.0.1</span></span><br></pre></td></tr></table></figure><p>babel 干了什么？</p><p>babel 会将我们的代码编译成如下形式:</p><p><img src="/img/postImg/babel-transfer.png" alt="bebel 转换"></p><h4 id="让在循环中使用函数变得轻而易举"><a href="#让在循环中使用函数变得轻而易举" class="headerlink" title="让在循环中使用函数变得轻而易举"></a>让在循环中使用函数变得轻而易举</h4><p>在 ES5, 如果你有一个函数  在循环中，形  如<code>for(var i = 0; i &lt; 3; i++) {…}</code>,如果你的函数需要使用变量，由于变量提升的缘故，可能会和  预期不一样，如果使用<code>let</code>, 你将不会遇到任何麻烦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 同一个refer</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]()); <span class="comment">// 3, 3, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// refer 到当前块级作用域的i</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]()); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 不能使用<code>const</code>，因为它是常量。除非你使用新<code>for...of</code>循环</p></blockquote><h3 id="2-词法this（通过箭头函数）"><a href="#2-词法this（通过箭头函数）" class="headerlink" title="2. 词法this（通过箭头函数）"></a>2. 词法<code>this</code>（通过箭头函数）</h3><p>在 ES5 中,<code>this</code> 可以取决于你在哪里调用、 你怎么调用， 因而导致了 JS 开发者无数的烦恼，ES6 通过词法<code>this</code> 消除了这个主要问题。</p><p>词法<code>this</code>是一个这样的特性：  即强制要求变量<code>this</code>天然指向当前定义的对象上。</p><p>两个在 ES5 中的问题，以及解决方案:</p><p>在下面的例子中，我们想要答打印 user 的 firstName 和 Salary， 但是当我们模拟从服务端获取  薪  金  数据，会发现当响应返回的时候，<code>this</code>指向的  是 window，而不是 person 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSalaryFromServer</span>(<span class="params">id, cb</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    cb(<span class="number">1000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  id: <span class="string">"1"</span>,</span><br><span class="line"></span><br><span class="line">  firstName: <span class="string">"chill"</span>,</span><br><span class="line"></span><br><span class="line">  lastName: <span class="string">"ryan"</span>,</span><br><span class="line"></span><br><span class="line">  printNameAndSalary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); <span class="comment">// underfined</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(salary); <span class="comment">// 1000</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fix 1</span></span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fix 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.firstName); <span class="comment">// chill</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 的解决方案:</p><p>简单的在代码中使用箭头函数（=&gt;），你就可以自动得到词法<code>this</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line">    // ...</span><br><span class="line">    getSalaryFromServer(this.id, (salary) =&gt;&#123;</span><br><span class="line">        console.log(self.firstName) // chill</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel 是如果将箭头函数转换成普通的 ES5 函数语法的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line">  printNameAndSalary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 可以看到，babel 也是通过把this指向暂存在另一个变量</span></span><br><span class="line">      <span class="built_in">console</span>.log(_this.firstName);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-处理arguments变量"><a href="#3-处理arguments变量" class="headerlink" title="3.处理arguments变量"></a>3.处理<code>arguments</code>变量</h3><p>在 ES5 中，<code>arguments</code> 表现的像是一个数组（比如我们可以正常的循环它），但是它却不是一个数组，因此，所有函数的方法，比如 sort、slice 等等是不能够使用的。</p><p>在 ES6 里， 我们可以使用  rest 参数的  特性, 形如<code>...args</code>,rest 参数是一个数组， 因此我们能够使用  各种数组的的方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySort</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Classes"><a href="#4-Classes" class="headerlink" title="4. Classes"></a>4. Classes</h3><p>从  概念上讲，JS 中并不存在像其他面向对象语言（如 JAVA） 那样的类的概念，但是  在很长时间里，JS 开发者已经把函数（也叫做构造函数）通过 <code>new</code> 关键词  产生的对象称之为类，</p><p>因为 JS 并不支持类（Class）, 仅仅  通过原型来模拟，导致现有的语法，无论是  目前正常使用 JS 的开发者，还是想用是使用传统 OO 语法的新开发者，都令人感到十分困惑。在一些场景尤其令人摸不着头脑，诸如创造子类，调用父级方法等等。</p><p>ES6  带来全新的  语法， 就像  大多数常见的编程语言一样，创建类这件事变得分成  简单。一下是 ES5 和 ES6 两张  创建类的方法的对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span>(<span class="params">id, x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.location(x, y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape.prototype.location = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Shape + <span class="string">"("</span> + <span class="keyword">this</span>.id + <span class="string">")"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape.prototype.getLocation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="keyword">this</span>.x,</span><br><span class="line"></span><br><span class="line">    y: <span class="keyword">this</span>.y</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span>(<span class="params">id, x, y, radius</span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>, id, x, y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式</span></span><br><span class="line"></span><br><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">Circle.prototype = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line">Circle.prototype.constructor = Circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line">Circle.defaultCircle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Circle(<span class="string">"default"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Circle &gt;"</span> + Shape.ptototype.toString.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.location(x, y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`shape :id = <span class="subst">$&#123;<span class="keyword">this</span>.id&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getLocaton() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      x: <span class="keyword">this</span>.x,</span><br><span class="line"></span><br><span class="line">      y: <span class="keyword">this</span>.y</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, x, y, radius) &#123;</span><br><span class="line">    <span class="keyword">super</span>(id, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDefaultCircle() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(<span class="string">"defalut"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Circle &gt;"</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UPDATE</strong>: 确保你你已经阅读了： <a href="https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65" target="_blank" rel="noopener">ES6 的  中的<code>Class</code>语法是新的糟粕吗?</a></p><h3 id="5-严格模式"><a href="#5-严格模式" class="headerlink" title="5. 严格模式"></a>5. 严格模式</h3><p>严格模式（“use strict”）帮组开发甄别一些常见的问题（或者说 js 中的缺陷），同时避免 JavaScript 的滥用。在 ES5， 严格模式是一个可选项，但是在 ES6，它是许多 ES6 特性所依赖的，因此很多开发者和工具库，比如 babel，自动在文件的顶部添加了<code>“use strict”</code>，默认开启 js 的严格模式来强迫我们写更好的 JS 代码。</p><p>以上 🙏</p><p><a href="https://medium.freecodecamp.org/mindset-lessons-from-a-year-with-react-1de862421981" target="_blank" rel="noopener">原文连接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript 6 的特性可以被分为以下几种类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;纯语法糖，比如 &lt;code&gt;class&lt;/code&gt; 语法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;JavaScript 增强性 
      
    
    </summary>
    
    
      <category term="Translation" scheme="http://yoursite.com/tags/Translation/"/>
    
      <category term="vanilla" scheme="http://yoursite.com/tags/vanilla/"/>
    
  </entry>
  
  <entry>
    <title>[译]理解 React v16 新的生命周期</title>
    <link href="http://yoursite.com/2018/09/20/understand-new-lifecycle-in-React-16/"/>
    <id>http://yoursite.com/2018/09/20/understand-new-lifecycle-in-React-16/</id>
    <published>2018-09-20T13:20:58.000Z</published>
    <updated>2018-10-28T17:26:27.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解-React-v16-4-的新的生命周期"><a href="#理解-React-v16-4-的新的生命周期" class="headerlink" title="理解 React v16.4+ 的新的生命周期"></a>理解 React v16.4+ 的新的生命周期</h1><blockquote><p>原文链接:<br><a href="https://blog.bitsrc.io/understanding-react-v16-4-new-component-lifecycle-methods-fa7b224efd7d" target="_blank" rel="noopener">Understanding React v16.4+ New Component Lifecycle Methods</a>（略有删减）</p></blockquote><p>ReactJs v16.3 为我们展现了显著变化的组件生命周期，废弃了一些生命周期同时增加了几个额外的生命周期。</p><p>在这篇文章，我们深入 React v16.3+ 的生命周期 ，我们会用 React 构建一个音乐播放器来获得实战经验。</p><h2 id="React-与-UI"><a href="#React-与-UI" class="headerlink" title="React 与 UI"></a>React 与 UI</h2><p>React 的官方介绍称：‘React 是一个用来构建 UI 的界面’。</p><p>用户界面是一个多  选项场景，用户可以做各种各样的事情，想 React 这样的第三库就是用于构建这类场景的。</p><p>用户通过在 UI 组件中点击、滑动、点击按钮、或者其他行为来于我们的应用交互。 所有的 UI 组件  在浏览器中诞生 并且在某个特定的时间点会消失。</p><h2 id="为什么生命周期函数很重要"><a href="#为什么生命周期函数很重要" class="headerlink" title="为什么生命周期函数很重要?"></a>为什么生命周期函数很重要?</h2><p>世间万物，所有的事物都有一系列的事件驱动。</p><p>详见原文，这里不做翻译，大意是  作者的一些  感悟。</p><p>如果可以感知这些生命周期， 我们就可以  就可以控制整个流向，毫无疑问可以帮我们产出更好的结果。</p><h2 id="废弃的方法于新的静态生命周期方法"><a href="#废弃的方法于新的静态生命周期方法" class="headerlink" title="废弃的方法于新的静态生命周期方法"></a>废弃的方法于新的静态生命周期方法</h2><p>在 React 16.3 中，有少数的生命周期方法被删除。目前，这些方法都增加了一个前缀 UNSAFE_ ，并将在下一个主要版本中完全删除。 同时， 现存的 React 应用可以向新的 React 生命周期逐渐迁移。</p><p>Componentwillmount，componentwillreceiveprobulps 和 componentententwillupdate 这样的方法被大量滥用，因为当前的实例中<code>this</code>是可用的，并且容易被滥用。 React 开发组决定删除了容易出错的方法，使整个 React 组件的生命周期更加简单。</p><p>为了提高反应的用户体验和性能，团队正朝着异步渲染的方向发展。 静态生命周期方法背后的动机主要是使方法更容易和兼容的异步渲染。</p><p>下面的链接是 Dan Abramov  制作  的关于异步渲染演示。<br><a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank" rel="noopener">video link</a></p><p>以下的方法是被废弃的:</p><p>1.componentWillMount</p><p>所有遗留的使用场景都可以被构造函数覆盖，被重命名为 UNSAFE_componentWillMount.</p><p>2.componentWillReceiveProps</p><p>新的静态方法 getDerivedStateFromProps 安全的重写  了方法，并且涵盖了 componentWillReceiveProps 的所有用例，这个方法被重命名为 UNSAFE_componentWillReceiveProps。</p><p>3.componentWillUpdate</p><p>新方法 getSnapshotBeforeUpdate 对此方法进行了安全的重写，涵盖了 componentWillUpdate 的所有用例。<br>该方法被重命名为 UNSAFE_componentWillUpdate。</p><h2 id="最新-React-组件生命周期的执行阶段"><a href="#最新-React-组件生命周期的执行阶段" class="headerlink" title="最新 React  组件生命周期的执行阶段"></a>最新 React  组件生命周期的执行阶段</h2><p>继承至 React.Component 的组件会  依次经历以下的阶段</p><ul><li>Mounting（装载）</li><li>Updating （更新）</li><li>Unmounting （卸载）</li></ul><p>下图代表了 React 的最新生命周期的阶段和方法。</p><p><img src="/img/postImg/lifecycle.png" alt="new-lifecycle-in-react"></p><h3 id="1-装载（Mounting）"><a href="#1-装载（Mounting）" class="headerlink" title="1) 装载（Mounting）"></a>1) 装载（Mounting）</h3><p>在 React 领域中，装载（mount）是指的是在 DOM 上加载组件。 这个阶段包含一组方法，这些方法在组件初始化时会被调用，然后加载到 DOM。</p><p>方法的调用顺序  如下：</p><ul><li>constructor</li></ul><p>这是每次创建组件时都会调用的第一个方法。 构造函数在组件的整个生命周期中只被调用一次。 它用于设置变量和组件状态的初始值。</p><p>使用方法: 设置组件的初始状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContraMusicPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br><span class="line"><span class="class"><span class="title">constructor</span>(<span class="title">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    volume: <span class="number">70</span>,</span><br><span class="line">    status: <span class="string">'pause'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们渲染 <code>&lt;ContraMusicPlayer&gt;</code> 组件，组件的初始状态将会是音量 70，处于暂停状态。</p><p>在 React 领域， construct 是唯一一个<code>this.state</code>直接使用的地方，在其他方法里面，更改<code>state</code>只能使用<code>this.setState()</code>.</p><ul><li>static getDerivedStateFromProps</li></ul><p>正如这个名字所建议的一样，从 props 获取驱动状态，适用于 state 是依赖于 props 的，因此，每当 props 发生变更的时候，state 必须  保持同步，这个方法在构造函数之后调用， 函数的  返回对象作为更新 state 的对象，如果返回 <code>null</code>,那么 state 就不会发生更新。</p><p><code>getDerivedStateFromProps</code>是一个静态的方法，因此它无法访问<code>this</code>。 该方法可以访问当前<code>props</code>和<code>state</code>。 因此，如果<code>state</code>依赖于<code>props</code>，那么这个状态就可以在这里更新。 这种方法是 React v16.3+ 中的全新添加。<br>使用方法: 保持 state 与传进来的 props 一致。 这个方法更安全地替换了 componentWillReceiveProps。 这个方法是一个纯函数，因此不应该在这里写任何产生副作用的方法。</p><blockquote><p>译者注：副作用并不是 react 专有的名词，这是一个描述函数行为的基本概念，一个有副作用的函数意味着，函数尝试改变当前函数作用域以外的变量，例如，改变全局变量、网络请求等等</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">  <span class="keyword">if</span> (state.value !== props.value) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        derivedValue: deriveValueFromProps(props),</span><br><span class="line">        mirroredProp: props.value</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">// when null is returned no update is made to the state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after getDerivedStateFromProps the state looks like as follows:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//    derivedValue: someValue,</span></span><br><span class="line"><span class="comment">//    mirrordValue: newPropValue</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，为了跟踪 props 值的变化，props 的实际值在会映射一份在 state 中， 用来与下一次 props 作比较。</p><p>有几种方法可以避免使用 props 来推导 state <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">参考这篇文章</a></p><ul><li>render</li></ul><p>这是在 React 组件中必需的方法，因为该方法预先准备  了装载生成浏览器中的 DOM 的元素。这是一个纯函数，意味着每次提供相同的输入都会给出相同的输出（相同的 UI）。该方法不应该有任何副作用，比如如改变状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">     &lt;PlayHeader&gt;</span><br><span class="line">       &lt;Status/&gt;</span><br><span class="line">       &lt;VolumeBar/&gt;</span><br><span class="line">       &lt;SeekBar/&gt;</span><br><span class="line">    &lt;<span class="regexp">/PlayHeader&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentDidMount</li></ul><p>The following example shows the setup of Highcharts when the DOM is ready</p><p>这是在组件挂载到浏览器 DOM 后立即调用的 hook 方法。</p><p>使用方法: 所有与浏览器 DOM 的直接交互，并与像 Highcharts 或 D3 这样的第三方库集成。</p><p>下面的示例显示了在 DOM 生成  好之后 Highcharts 实例的生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.props.modules) &#123;</span><br><span class="line">            <span class="keyword">this</span>.props.modules.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">module</span>(Highcharts);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set container which the chart should render to.</span></span><br><span class="line">        <span class="keyword">this</span>.chart = <span class="keyword">new</span> Highcharts[<span class="keyword">this</span>.props.type || <span class="string">"Chart"</span>](</span><br><span class="line">            <span class="keyword">this</span>.props.container,</span><br><span class="line">            <span class="keyword">this</span>.props.options</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-更新（Updating）"><a href="#2-更新（Updating）" class="headerlink" title="2) 更新（Updating）"></a>2) 更新（Updating）</h3><p>当 React 组件在浏览  器上装载并通过接收新的更新来更新组件时，这个阶段就开始了。 组件可以通过两种方式进行更新，接收从父母那里发送新的 props 或者更新当前 state。</p><p>当更新以任何方式发生时，将按顺序调用的方法列表:</p><ul><li>static getDerivedStateFromProps</li></ul><p>This method behaves exactly as defined above in mounting phase.<br>这个方法得行为和之前在装载阶段描述的完全一致</p><ul><li>shouldComponentUpdate</li></ul><p>这个方法告诉 React，当组件正在更新时，它应该重新渲染还是跳过渲染。</p><p>这个方法是  选择（原文:a question），是否应该更新组件？因此，此方法应返回 true 或 false，因此，组件将被重新渲染或跳过。默认情况下，此方法返回 true。</p><p>使用方法: 本例是渲染成本相当高的情况之一，我们希望只在 props 状态发生变化时才重新渲染组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate = <span class="keyword">this</span>.props.status !== nextProps.status;</span><br><span class="line">  <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，假设对于每个渲染，组件生成一千个素数。 如果某些应用有这种逻辑，那么我们就可以控制什么时候需要它，并确保组件被渲染。</p><p>然后将组件呈现出来(细节在装载阶段)。</p><ul><li>getSnapshotBeforeUpdate</li></ul><p>这个方法在渲染创建了 React 元素之后被调用，在它从虚拟 DOM 更新到实际 DOM 之前。 这个阶段称为预提交(<code>pre-commit</code>)阶段。</p><p>这种方法可以访问以前和当前的 props 和 state。</p><p>如果方法 snapshotbeforeupdate 返回一个值，那么 componentDidUpdate 第三个参数会获得这个值（<code>componentDidUpdate(prevProps, prevState, snapshot)</code>），那么 UI 就可以在渲染之前和之后进行同步。</p><p>使用方法: 如果您希望在当前 DOM 的 state 与更新的 DOM 之间保持同步，这个方法非常有用。 例如滚动位置、音频 / 视频、文字选择、光标位置、tooltip 位置等等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot = <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ScrollingList <span class="keyword">extends</span> React.Component&lt;Props, State, Snapshot&gt; &#123;</span><br><span class="line">  listRef = React.createRef();</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps: Props, prevState: State): Snapshot &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the current height of the list so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.listRef.value.scrollHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps: Props, prevState: State, snapshot: Snapshot) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, then we've just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.listRef.value.scrollTop +=</span><br><span class="line">        <span class="keyword">this</span>.listRef.value.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>想了解更多可以查看这个<a href="https://github.com/reactjs/rfcs/blob/master/text/0033-new-commit-phase-lifecycles.md#basic-example" target="_blank" rel="noopener">链接</a>.</p><ul><li>componentDidUpdate</li></ul><p>当新更新的组件在 DOM 中更新时，将执行 componentDidUpdate ，该方法用于重新触发第三方库的使用，并确保这些库也更新和重新加载自己。</p><p>用法: 用例大多与 componentDidMount 的用例相似，以保持第三方库或用户界面与每次更新同步。</p><h3 id="3-卸载（Unmounting）"><a href="#3-卸载（Unmounting）" class="headerlink" title="3) 卸载（Unmounting）"></a>3) 卸载（Unmounting）</h3><p>在这个阶段，组件将不再被需要，组件将从 DOM 中卸载。</p><p>下面是这个阶段调用的方法:</p><ul><li>componentWillUnmount 这个方法是生命周期的最后方法。 这是在组件从 DOM 中移除之前执行的。</li></ul><p>使用方法: 在这个方法中，我们做与组件相关的所有清理动作。</p><p>例如，在登出的时候，用户的详细信息和所有权限 token 可以在卸载主要组件之前被清除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line"><span class="keyword">this</span>.chart.destroy();</span><br><span class="line"><span class="keyword">this</span>.resetLocalStorage();</span><br><span class="line"><span class="keyword">this</span>.clearSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:)"></a>总结:)</h2><p>理解 React 的生命周期方法有助于我们在构建 React 组件和应用程序时产生最好的结果。 了解它们是如何工作的，如何使用它们可以提高性能，并且可以帮助我们保持更新和充分利用 React 16.4+ 。👏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理解-React-v16-4-的新的生命周期&quot;&gt;&lt;a href=&quot;#理解-React-v16-4-的新的生命周期&quot; class=&quot;headerlink&quot; title=&quot;理解 React v16.4+ 的新的生命周期&quot;&gt;&lt;/a&gt;理解 React v16.4+ 的新的
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="Translation" scheme="http://yoursite.com/tags/Translation/"/>
    
  </entry>
  
</feed>
