<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DAY DREAM</title>
  
  <subtitle>go big or go home</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-21T17:00:50.941Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ryanchill</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译]5个在ES6中被修复的Javascript缺陷</title>
    <link href="http://yoursite.com/2018/09/30/five-bad-parts-fix-in-es6/"/>
    <id>http://yoursite.com/2018/09/30/five-bad-parts-fix-in-es6/</id>
    <published>2018-09-30T09:06:51.000Z</published>
    <updated>2018-10-21T17:00:50.941Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 6 的特性可以被分为以下几种类型</p><ul><li><ol><li>纯语法糖，比如 <code>class</code> 语法</li></ol></li><li><ol start="2"><li>JavaScript 增强性  功能，比如 <code>import</code></li></ol></li><li><ol start="3"><li>修复了 JS 中一些缺陷，比如 <code>let</code> 关键字</li></ol></li></ul><p>本文着重分析第三种类型，接下来，让我们来了解下 JavaScript 中哪些「Bad Parts」被 ES6 修复了。</p><blockquote><p> 我希望当你阅读完本文，你可以意识到使用一些简单 ES6 特性给你带来的巨大便利。</p></blockquote><h3 id="1-Block-Scope"><a href="#1-Block-Scope" class="headerlink" title="1. Block Scope"></a>1. Block Scope</h3><p>ES5 只有函数作用域(比如你定义在函数块里面的代码来形成作用域),因此带来了很多问题, ES6  提供了「块级别」的作用域（通过大括号包裹），同时使用 <code>let</code>  和 <code>const</code> 来代替 <code>var</code>。</p><h4 id="防止变量提升到外部作用域"><a href="#防止变量提升到外部作用域" class="headerlink" title="防止变量提升到外部作用域"></a>防止变量提升到外部作用域</h4><p>下面的例子可以看出来 变量 <code>bouns</code>没有被提升到 <code>if</code> 块级作用域之外 ， 变得其他像大多数编程语言那样可预测。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSalary</span>(<span class="params">addBonus</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (addBonus) &#123;</span><br><span class="line">    <span class="keyword">var</span> bonus = <span class="number">100</span>; <span class="comment">// 会被提升至if作用域之外</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base + bonus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base + bonus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">false</span>)); <span class="comment">// NaN 因为变量 bonus 被提升了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">true</span>)); <span class="comment">// 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> base = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSalary</span>(<span class="params">addBonus</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (addBonus) &#123;</span><br><span class="line">    <span class="keyword">let</span> bonus = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base + bonus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> base + bonus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">false</span>)); <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSalary(<span class="literal">true</span>)); <span class="comment">// 1100</span></span><br></pre></td></tr></table></figure><h4 id="防止重复定义变量"><a href="#防止重复定义变量" class="headerlink" title="防止重复定义变量"></a>防止重复定义变量</h4><p>ES6 不允许使用<code>let</code>或者<code>const</code>定义的变量在同一个作用域中重复定义，这有效的避免了不同库之间的函数表达式的重复（注：这里翻译有点问题，原文为:This is very helpful in avoiding duplicate function expressions coming from different libraries ）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span>  add  = <span class="function">(<span class="params">a, b</span>) =&gt;</span>  a  +  b;</span><br><span class="line"><span class="keyword">const</span>  add  = <span class="function">(<span class="params">a, b</span>) =&gt;</span>  a  +  b; <span class="comment">// 会抛出重复定义错误</span></span><br></pre></td></tr></table></figure><h4 id="取代-IIFE-的功能"><a href="#取代-IIFE-的功能" class="headerlink" title=" 取代 IIFE 的功能"></a> 取代 IIFE 的功能</h4><p>在 ES5，就像下面的例子， 我们不得不使用立即执行函数(IIFE)来确保全局作用域不会被污染，在 ES6 中，我们只需要简单的把代码包裹在<code>{}</code>中,使用 <code>let</code> 和 <code>const</code>  来定义变量就可以获得相同的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.betterJQ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Version <span class="subst">$&#123;<span class="built_in">window</span>.bettterJQ.version&#125;</span> already exists`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> version = <span class="string">"v0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Better JQuery"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> betterJQ = &#123;</span><br><span class="line">      name,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      ajax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="string">"requst!"</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.betterJQ = betterJQ; <span class="comment">// 挂载到全局对象上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.betterJQ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Version <span class="subst">$&#123;<span class="built_in">window</span>.bettterJQ.version&#125;</span> already exists`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> version = <span class="string">"v0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">"Better JQuery"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> betterJQ = &#123;</span><br><span class="line">      name,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      ajax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="string">"requst!"</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.betterJQ = betterJQ; <span class="comment">// 挂载到全局对象上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(version); <span class="comment">// Reference Error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Reference Error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(betterJQ.version); <span class="comment">// v0.0.1</span></span><br></pre></td></tr></table></figure><p>babel 干了什么？</p><p>babel 会将我们的代码编译成如下形式:</p><p><img src="/img/postImg/babel-transfer.png" alt="bebel 转换"></p><h4 id="让在循环中使用函数变得轻而易举"><a href="#让在循环中使用函数变得轻而易举" class="headerlink" title="让在循环中使用函数变得轻而易举"></a>让在循环中使用函数变得轻而易举</h4><p>在 ES5, 如果你有一个函数  在循环中，形  如<code>for(var i = 0; i &lt; 3; i++) {…}</code>,如果你的函数需要使用变量，由于变量提升的缘故，可能会和  预期不一样，如果使用<code>let</code>, 你将不会遇到任何麻烦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 同一个refer</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]()); <span class="comment">// 3, 3, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// refer 到当前块级作用域的i</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]()); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 不能使用<code>const</code>，因为它是常量。除非你使用新<code>for...of</code>循环</p></blockquote><h3 id="2-词法this（通过箭头函数）"><a href="#2-词法this（通过箭头函数）" class="headerlink" title="2. 词法this（通过箭头函数）"></a>2. 词法<code>this</code>（通过箭头函数）</h3><p>在 ES5 中,<code>this</code> 可以取决于你在哪里调用、 你怎么调用，因而导致了 JS 开发者无数的烦恼，ES6 通过词法<code>this</code> 消除了这个主要问题。</p><p>词法<code>this</code>是一个这样的特性：  即强制要求变量<code>this</code>天然指向当前定义的对象上。</p><p>两个在 ES5 中的问题，以及解决方案:</p><p>在下面的例子中，我们想要答打印 user 的 firstName 和 Salary， 但是当我们模拟从服务端获取  薪  金  数据，会发现当响应返回的时候，<code>this</code>指向的  是 window，而不是 person 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSalaryFromServer</span>(<span class="params">id, cb</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    cb(<span class="number">1000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  id: <span class="string">"1"</span>,</span><br><span class="line"></span><br><span class="line">  firstName: <span class="string">"chill"</span>,</span><br><span class="line"></span><br><span class="line">  lastName: <span class="string">"ryan"</span>,</span><br><span class="line"></span><br><span class="line">  printNameAndSalary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); <span class="comment">// underfined</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(salary); <span class="comment">// 1000</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fix 1</span></span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;).bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fix 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.firstName); <span class="comment">// chill</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 的解决方案:</p><p>简单的在代码中使用箭头函数（=&gt;），你就可以自动得到词法<code>this</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">    // ...</span><br><span class="line">    getSalaryFromServer(this.id, (salary) =&gt;&#123;</span><br><span class="line">        console.log(self.firstName) // chill</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel 是如果将箭头函数转换成普通的 ES5 函数语法的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  printNameAndSalary: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">    getSalaryFromServer(<span class="keyword">this</span>.id, <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可以看到，babel 也是通过把this指向暂存在另一个变量</span></span><br><span class="line">      <span class="built_in">console</span>.log(_this.firstName);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理arguments变量"><a href="#3-处理arguments变量" class="headerlink" title="3.处理arguments变量"></a>3.处理<code>arguments</code>变量</h3><p>在 ES5 中，<code>arguments</code> 表现的像是一个数组（比如我们可以正常的循环它），但是它却不是一个数组，因此，所有函数的方法，比如 sort、slice 等等是不能够使用的。</p><p>在 ES6 里， 我们可以使用  rest 参数的  特性, 形如<code>...args</code>,rest 参数是一个数组， 因此我们能够使用  各种数组的的方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySort</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Classes"><a href="#4-Classes" class="headerlink" title="4. Classes"></a>4. Classes</h3><p>从概念上讲，JS 中并不存在像其他面向对象语言（如 JAVA）那样的类的概念，但是在很长时间里，JS开发者已经把函数（也叫做构造函数）通过 <code>new</code> 关键词产生的对象称之为类，</p><p>因为 JS 并不支持类（Class）,仅仅通过原型来模拟，导致现有的语法，无论是目前正常使用JS的开发者，还是想用是使用传统OO语法的新开发者，都令人感到十分困惑。在一些场景尤其令人摸不着头脑，诸如创造子类，调用父级方法等等。</p><p>ES6 带来全新的语法， 就像大多数常见的编程语言一样，创建类这件事变得分成简单。一下是ES5和ES6两张创建类的方法的对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span>(<span class="params">id, x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.location(x, y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape.prototype.location = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Shape + <span class="string">"("</span> + <span class="keyword">this</span>.id + <span class="string">")"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Shape.prototype.getLocation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="keyword">this</span>.x,</span><br><span class="line"></span><br><span class="line">    y: <span class="keyword">this</span>.y</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span>(<span class="params">id, x, y, radius</span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>, id, x, y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式</span></span><br><span class="line"></span><br><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">Circle.prototype = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line">Circle.prototype.constructor = Circle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line">Circle.defaultCircle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Circle(<span class="string">"default"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Circle &gt;"</span> + Shape.ptototype.toString.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.location(x, y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`shape :id = <span class="subst">$&#123;<span class="keyword">this</span>.id&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getLocaton() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      x: <span class="keyword">this</span>.x,</span><br><span class="line"></span><br><span class="line">      y: <span class="keyword">this</span>.y</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id, x, y, radius) &#123;</span><br><span class="line">    <span class="keyword">super</span>(id, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDefaultCircle() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(<span class="string">"defalut"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Circle &gt;"</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UPDATE</strong>: 确保你你已经阅读了： <a href="https://medium.com/@rajaraodv/is-class-in-es6-the-new-bad-part-6c4e6fe1ee65" target="_blank" rel="noopener">ES6的中的<code>Class</code>语法是新的糟粕吗?</a></p><h3 id="5-严格模式"><a href="#5-严格模式" class="headerlink" title="5. 严格模式"></a>5. 严格模式</h3><p>严格模式（“use strict”）帮组开发甄别一些常见的问题（或者说js中的缺陷），同时避免JavaScript的滥用。在ES5，严格模式是一个可选项，但是在ES6，它是许多ES6特性所依赖的，因此很多开发者和工具库，比如babel，自动在文件的顶部添加了<code>“use strict”</code>，默认开启js的严格模式来强迫我们写更好的JS代码。</p><p>以上🙏</p><p><a href="https://medium.freecodecamp.org/mindset-lessons-from-a-year-with-react-1de862421981" target="_blank" rel="noopener">原文连接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript 6 的特性可以被分为以下几种类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;纯语法糖，比如 &lt;code&gt;class&lt;/code&gt; 语法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;JavaScript 增强性 
      
    
    </summary>
    
    
      <category term="vanilla" scheme="http://yoursite.com/tags/vanilla/"/>
    
      <category term="Translation" scheme="http://yoursite.com/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>[译]理解 React v16 新的生命周期</title>
    <link href="http://yoursite.com/2018/09/20/understand-new-lifecycle-in-React-16/"/>
    <id>http://yoursite.com/2018/09/20/understand-new-lifecycle-in-React-16/</id>
    <published>2018-09-20T13:20:58.000Z</published>
    <updated>2018-10-24T13:41:24.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解-React-v16-4-的新的生命周期"><a href="#理解-React-v16-4-的新的生命周期" class="headerlink" title="理解 React v16.4+ 的新的生命周期"></a>理解 React v16.4+ 的新的生命周期</h1><blockquote><p>原文链接:<br><a href="https://blog.bitsrc.io/understanding-react-v16-4-new-component-lifecycle-methods-fa7b224efd7d" target="_blank" rel="noopener">Understanding React v16.4+ New Component Lifecycle Methods</a>（略有删减）</p></blockquote><p>ReactJs v16.3 为我们展现了显著变化的组件生命周期，废弃了一些生命周期同时增加了几个额外的生命周期。</p><p>在这篇文章，我们深入 React v16.3+ 的生命周期 ，我们会用React构建一个音乐播放器来获得实战经验。</p><h2 id="React-与-UI"><a href="#React-与-UI" class="headerlink" title="React 与 UI"></a>React 与 UI</h2><p>React 的官方介绍称：‘React 是一个用来构建 UI 的界面’。</p><p>用户界面是一个多选项场景，用户可以做各种各样的事情，想React这样的第三库就是用于构建这类场景的。</p><p>用户通过在 UI 组件中点击、滑动、点击按钮、或者其他行为来于我们的应用交互。 所有的UI组件在浏览器中诞生 并且在某个特定的时间点会消失。</p><h2 id="为什么生命周期函数很重要"><a href="#为什么生命周期函数很重要" class="headerlink" title="为什么生命周期函数很重要?"></a>为什么生命周期函数很重要?</h2><p>世间万物，所有的事物都有一系列的事件驱动。</p><p>详见原文，这里不做翻译，大意是作者的一些感悟。</p><p>如果可以感知这些生命周期，我们就可以就可以控制整个流向，毫无疑问可以帮我们产出更好的结果。</p><h2 id="废弃的方法于新的静态生命周期方法"><a href="#废弃的方法于新的静态生命周期方法" class="headerlink" title="废弃的方法于新的静态生命周期方法"></a>废弃的方法于新的静态生命周期方法</h2><p>在 React 16.3中，有少数的生命周期方法被删除。目前，这些方法都增加了一个前缀 UNSAFE_ ，并将在下一个主要版本中完全删除。 同时，现存的React应用可以向新的 React 生命周期逐渐迁移。</p><p>Componentwillmount，componentwillreceiveprobulps 和 componentententwillupdate 这样的方法被大量滥用，因为当前的实例中<code>this</code>是可用的，并且容易被滥用。 React 开发组决定删除了容易出错的方法，使整个React组件的生命周期更加简单。</p><p>为了提高反应的用户体验和性能，团队正朝着异步渲染的方向发展。 静态生命周期方法背后的动机主要是使方法更容易和兼容的异步渲染。</p><p>下面的链接是 Dan Abramov 制作的关于异步渲染演示。<br><a href="https://www.youtube.com/watch?v=nLF0n9SACd4" target="_blank" rel="noopener">video link</a></p><p>以下的方法是被废弃的:</p><p>1.componentWillMount</p><p>所有遗留的使用场景都可以被构造函数覆盖，被重命名为UNSAFE_componentWillMount.</p><p>2.componentWillReceiveProps</p><p>新的静态方法 getDerivedStateFromProps 安全的重写了方法，并且涵盖了 componentWillReceiveProps 的所有用例，这个方法被重命名为 UNSAFE_componentWillReceiveProps。</p><p>3.componentWillUpdate</p><p>新方法 getSnapshotBeforeUpdate 对此方法进行了安全的重写，涵盖了 componentWillUpdate 的所有用例。<br>该方法被重命名为 UNSAFE_componentWillUpdate。</p><h2 id="最新-React-组件生命周期的执行阶段"><a href="#最新-React-组件生命周期的执行阶段" class="headerlink" title="最新 React 组件生命周期的执行阶段"></a>最新 React 组件生命周期的执行阶段</h2><p>继承至React.Component的组件会依次经历以下的阶段</p><ul><li>Mounting（装载）</li><li>Updating （更新）</li><li>Unmounting （卸载）</li></ul><p>下图代表了 React 的最新生命周期的阶段和方法。<br><img src="/img/postImg/lifecycle.png" alt="new-lifecycle-in-react"></p><h3 id="1-装载（Mounting）"><a href="#1-装载（Mounting）" class="headerlink" title="1) 装载（Mounting）"></a>1) 装载（Mounting）</h3><p>在 React 领域中，装载（mount）是指的是在 DOM 上加载组件。 这个阶段包含一组方法，这些方法在组件初始化时会被调用，然后加载到 DOM。</p><p>方法的调用顺序如下：</p><ul><li>constructor</li></ul><p>这是每次创建组件时都会调用的第一个方法。 构造函数在组件的整个生命周期中只被调用一次。 它用于设置变量和组件状态的初始值。</p><p>使用方法: 设置组件的初始状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContraMusicPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br><span class="line"><span class="class"><span class="title">constructor</span>(<span class="title">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    volume: <span class="number">70</span>,</span><br><span class="line">    status: <span class="string">'pause'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们渲染 <code>&lt;ContraMusicPlayer&gt;</code> 组件，组件的初始状态将会是音量70，处于暂停状态。</p><p>在 React 领域， construct 是唯一一个<code>this.state</code>直接使用的地方，在其他方法里面，更改<code>state</code>只能使用<code>this.setState()</code>.</p><ul><li>static getDerivedStateFromProps</li></ul><p>正如这个名字所建议的一样，从props 获取驱动状态，适用于state是依赖于props的，因此，每当props发生变更的时候，state必须保持同步，这个方法在构造函数之后调用，函数的返回对象作为更新state的对象，如果返回<code>null</code>,那么state就不会发生更新。</p><p><code>getDerivedStateFromProps</code>是一个静态的方法，因此它无法访问<code>this</code>。 该方法可以访问当前<code>props</code>和<code>state</code>。 因此，如果<code>state</code>依赖于<code>props</code>，那么这个状态就可以在这里更新。 这种方法是 React v16.3+ 中的全新添加。<br>使用方法: 保持state与传进来的props一致。 这个方法更安全地替换了 componentWillReceiveProps。 这个方法是一个纯函数，因此不应该在这里写任何产生副作用的方法。</p><blockquote><p>译者注：副作用并不是react专有的名词，这是一个描述函数行为的基本概念，一个有副作用的函数意味着，函数尝试改变当前函数作用域以外的变量，例如，改变全局变量、网络请求等等</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">  <span class="keyword">if</span> (state.value !== props.value) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        derivedValue: deriveValueFromProps(props),</span><br><span class="line">        mirroredProp: props.value</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">// when null is returned no update is made to the state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after getDerivedStateFromProps the state looks like as follows:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//    derivedValue: someValue,</span></span><br><span class="line"><span class="comment">//    mirrordValue: newPropValue</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，为了跟踪props值的变化，props的实际值在会映射一份在state中，用来与下一次props作比较。</p><p>有几种方法可以避免使用props来推导state <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">参考这篇文章</a></p><ul><li>render</li></ul><p>这是在 React 组件中必需的方法，因为该方法预先准备了装载生成浏览器中的DOM的元素。这是一个纯函数，意味着每次提供相同的输入都会给出相同的输出（相同的UI）。该方法不应该有任何副作用，比如如改变状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">     &lt;PlayHeader&gt;</span><br><span class="line">       &lt;Status/&gt;</span><br><span class="line">       &lt;VolumeBar/&gt;</span><br><span class="line">       &lt;SeekBar/&gt;</span><br><span class="line">    &lt;<span class="regexp">/PlayHeader&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentDidMount</li></ul><p>The following example shows the setup of Highcharts when the DOM is ready</p><p>这是在组件挂载到浏览器 DOM 后立即调用的 hook 方法。</p><p>使用方法: 所有与浏览器 DOM 的直接交互，并与像 Highcharts 或 D3这样的第三方库集成。 </p><p>下面的示例显示了在 DOM 生成好之后 Highcharts 实例的生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.props.modules) &#123;</span><br><span class="line">            <span class="keyword">this</span>.props.modules.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">module</span>(Highcharts);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set container which the chart should render to.</span></span><br><span class="line">        <span class="keyword">this</span>.chart = <span class="keyword">new</span> Highcharts[<span class="keyword">this</span>.props.type || <span class="string">"Chart"</span>](</span><br><span class="line">            <span class="keyword">this</span>.props.container, </span><br><span class="line">            <span class="keyword">this</span>.props.options</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-更新（Updating）"><a href="#2-更新（Updating）" class="headerlink" title="2) 更新（Updating）"></a>2) 更新（Updating）</h3><p>当 React 组件在浏览器上装载并通过接收新的更新来更新组件时，这个阶段就开始了。 组件可以通过两种方式进行更新，接收从父母那里发送新的props或者更新当前state。</p><p>当更新以任何方式发生时，将按顺序调用的方法列表:</p><ul><li>static getDerivedStateFromProps</li></ul><p>This method behaves exactly as defined above in mounting phase.<br>这个方法得行为和之前在装载阶段描述的完全一致</p><ul><li>shouldComponentUpdate</li></ul><p>这个方法告诉 React，当组件正在更新时，它应该重新渲染还是跳过渲染。</p><p>这个方法是选择（原文:a question），是否应该更新组件？因此，此方法应返回 true 或 false，因此，组件将被重新渲染或跳过。默认情况下，此方法返回 true。</p><p>使用方法: 本例是渲染成本相当高的情况之一，我们希望只在props状态发生变化时才重新渲染组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate = <span class="keyword">this</span>.props.status !== nextProps.status;</span><br><span class="line">  <span class="keyword">return</span> shouldUpdate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，假设对于每个渲染，组件生成一千个素数。 如果某些应用有这种逻辑，那么我们就可以控制什么时候需要它，并确保组件被渲染。</p><p>然后将组件呈现出来(细节在装载阶段)。</p><ul><li>getSnapshotBeforeUpdate</li></ul><p>这个方法在渲染创建了 React 元素之后被调用，在它从虚拟 DOM 更新到实际 DOM 之前。 这个阶段称为预提交(<code>pre-commit</code>)阶段。</p><p>这种方法可以访问以前和当前的props和state。</p><p>如果方法 snapshotbeforeupdate 返回一个值，那么 componentDidUpdate 第三个参数会获得这个值（<code>componentDidUpdate(prevProps, prevState, snapshot)</code>），那么 UI 就可以在渲染之前和之后进行同步。</p><p>使用方法: 如果您希望在当前 DOM 的 state 与更新的 DOM 之间保持同步，这个方法非常有用。 例如滚动位置、音频 / 视频、文字选择、光标位置、tooltip位置等等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot = <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ScrollingList <span class="keyword">extends</span> React.Component&lt;Props, State, Snapshot&gt; &#123;</span><br><span class="line">  listRef = React.createRef();</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(</span><br><span class="line">    prevProps: Props,</span><br><span class="line">    prevState: State</span><br><span class="line">  ): Snapshot &#123;</span><br><span class="line">    <span class="comment">// Are we adding new items to the list?</span></span><br><span class="line">    <span class="comment">// Capture the current height of the list so we can adjust scroll later.</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.listRef.value.scrollHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(</span><br><span class="line">    prevProps: Props,</span><br><span class="line">    prevState: State,</span><br><span class="line">    snapshot: Snapshot</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// If we have a snapshot value, then we've just added new items.</span></span><br><span class="line">    <span class="comment">// Adjust scroll so these new items don't push the old ones out of view.</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.listRef.value.scrollTop +=</span><br><span class="line">        <span class="keyword">this</span>.listRef.value.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>想了解更多可以查看这个<a href="https://github.com/reactjs/rfcs/blob/master/text/0033-new-commit-phase-lifecycles.md#basic-example" target="_blank" rel="noopener">链接</a>.</p><ul><li>componentDidUpdate</li></ul><p>当新更新的组件在 DOM 中更新时，将执行 componentDidUpdate ，该方法用于重新触发第三方库的使用，并确保这些库也更新和重新加载自己。</p><p>用法: 用例大多与 componentDidMount 的用例相似，以保持第三方库或用户界面与每次更新同步。</p><h3 id="3-卸载（Unmounting）"><a href="#3-卸载（Unmounting）" class="headerlink" title="3) 卸载（Unmounting）"></a>3) 卸载（Unmounting）</h3><p>在这个阶段，组件将不再被需要，组件将从 DOM 中卸载。</p><p>下面是这个阶段调用的方法:</p><ul><li>componentWillUnmount 这个方法是生命周期的最后方法。 这是在组件从 DOM 中移除之前执行的。</li></ul><p>使用方法: 在这个方法中，我们做与组件相关的所有清理动作。</p><p>例如，在登出的时候，用户的详细信息和所有权限token可以在卸载主要组件之前被清除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line"><span class="keyword">this</span>.chart.destroy();</span><br><span class="line"><span class="keyword">this</span>.resetLocalStorage();</span><br><span class="line"><span class="keyword">this</span>.clearSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:)"></a>总结:)</h2><p>理解 React 的生命周期方法有助于我们在构建 React 组件和应用程序时产生最好的结果。 了解它们是如何工作的，如何使用它们可以提高性能，并且可以帮助我们保持更新和充分利用 React 16.4+ 。👏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理解-React-v16-4-的新的生命周期&quot;&gt;&lt;a href=&quot;#理解-React-v16-4-的新的生命周期&quot; class=&quot;headerlink&quot; title=&quot;理解 React v16.4+ 的新的生命周期&quot;&gt;&lt;/a&gt;理解 React v16.4+ 的新的
      
    
    </summary>
    
    
      <category term="Translation" scheme="http://yoursite.com/tags/Translation/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
</feed>
